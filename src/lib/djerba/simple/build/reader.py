"""Read input data for Djerba"""

import csv
import json
import jsonschema
import djerba.simple.constants as constants
from djerba.simple.build.containers import gene, sample

class reader:
    """
    Parent class for Djerba data readers.

    Subclasses need to:
    - Read data
    - Store it in gene and sample objects
    - Use the objects to update self.genes and self.sample_info
    """

    GENE_METRICS_KEY = 'gene_metrics'
    GENE_NAME_KEY = 'Gene'
    ITEMS_KEY = 'items'
    PROPERTIES_KEY = 'properties'
    REVIEW_STATUS_KEY = 'review_status'
    SAMPLE_INFO_KEY = 'sample_info'
    SAMPLE_NAME_KEY = 'sample_name'

    def __init__(self, config, schema):
        """Constructor for superclass; should be called in all subclass constructors"""
        self.config = config
        self.schema = schema
        self.genes = {} # gene name -> gene object
        self.sample_info = sample({}, schema)  # empty sample object

    def get_genes_list(self):
        return list(self.genes.values())

    def get_output(self, require_complete=True, validate=True):
        """
        Get final output, ready to be written as JSON
        """
        if require_complete and not self.is_complete():
            raise RuntimeError("Refusing to generate output from incomplete Djerba reader")
        output = {}
        output[self.GENE_METRICS_KEY] = [x.get_attributes() for x in self.genes.values()]
        output[self.REVIEW_STATUS_KEY] = -1
        output[self.SAMPLE_INFO_KEY] = self.sample_info.get_attributes()
        output[self.SAMPLE_NAME_KEY] = self.sample_info.get_name()
        if validate:
            jsonschema.validate(output, self.schema)
        return output

    def get_sample_info(self):
        return self.sample_info

    def is_complete(self):
        complete = True
        for gene in self.genes.values():
            if not gene.is_complete():
                complete = False
                break
        if complete: # all genes are OK, check the sample
            complete = self.sample_info.is_complete()
        return complete

    def total_genes(self):
        return len(self.genes)

    def update_multiple_genes(self, new_genes):
        # input an array of gene objects
        for new_gene in new_genes:
            self.update_single_gene(new_gene)

    def update_single_gene(self, new_gene):
        # input a single gene object
        name = new_gene.get_name()
        if name == None:
            raise RunTimeError("Gene name is required")
        elif name in self.genes:
            self.genes[name].update(new_gene)
        else:
            self.genes[name] = new_gene

    def update_sample_info(self, sample_info):
        # update with a sample info object
        self.sample_info.update(sample_info)

class multiple_reader(reader):
    """Create a list of single_reader objects; read data; collate into JSON report"""

    def __init__(self, config, schema):
        """config input is an iterable of single-reader config objects """
        super().__init__(config, schema)
        self.factory = reader_factory()
        self.read_all()

    def read_all(self):
        """Similarly to single_reader, this is called as part of the constructor"""
        for single_config in self.config: # array of reader configuration objects
            reader = self.factory.create_instance(single_config, self.schema)
            self.update_sample_info(reader.get_sample_info())
            self.update_multiple_genes(reader.get_genes_list())

class single_reader(reader):
    """Read a single data source with parameters in config, using a read() method"""

    def __init__(self, config, schema):
        super().__init__(config, schema)
        self.read()

class json_reader(single_reader):
    """
    Reader for JSON data.
    Supply input as JSON, as default/fallback if other sources not available
    """

    def read(self):
        """
        Similarly to multiple_reader, this is called as part of the constructor
        """
        gene_metrics = self.config.get(self.GENE_METRICS_KEY)
        if gene_metrics:
            for attributes in gene_metrics:
                self.update_single_gene(gene(attributes, self.schema))
        sample_attributes = self.config.get(self.SAMPLE_INFO_KEY)
        if sample_attributes:
            self.update_sample_info(sample(sample_attributes, self.schema))
        # TODO warn if both gene metrics and sample attributes are missing

class mastersheet_reader(single_reader):
    """
    Reader for the mastersheet, generated by 1-linkNiassa.sh in CGI-Tools
    """

    ANALYSIS_UNIT_KEY = 'analysis_unit'
    MASTERSHEET_PATH_KEY = 'mastersheet_path'
    PATIENT_ID_KEY = 'PATIENT_ID'

    def read(self):
        patient_id = None
        for key in [self.MASTERSHEET_PATH_KEY, self.ANALYSIS_UNIT_KEY]:
            if not key in self.config:
                msg = "Missing required configuration parameter: %s" % key
                raise RuntimeError(msg)
        with open(self.config.get(self.MASTERSHEET_PATH_KEY), newline='') as ms_file:
            csv_reader = csv.reader(ms_file, delimiter="|")
            for row in csv_reader:
                if row[5] == 'WG' and row[10] == self.config.get(self.ANALYSIS_UNIT_KEY):
                    #tumor_id = row[11]
                    #normal_id = row[12]
                    patient_id = row[1]
                    break
        if not patient_id:
            msg = "Cannot find %s in mastersheet %s" % (self.PATIENT_ID_KEY, ms_path)
            raise RuntimeError(msg)
        attributes = {
            self.PATIENT_ID_KEY: patient_id
        }
        self.sample_info = sample(attributes, self.schema)

# TODO more readers for mafffile, segfile, fusfile, gepfile
# upstream "builder" class to find where these files are, and generate a reader config
# cf. config.build_clinical_report_meta

class reader_factory:
    """Given the config, construct a reader of the appropriate subclass"""

    def __init__(self):
        pass

    def create_instance(self, config, schema):
        """
        Return an instance of the reader class named in the config
        Config is a dictionary with a reader_class name, plus other parameters as needed
        """
        classname = config.get(constants.READER_CLASS_KEY)
        if classname == None:
            msg = "Unknown or missing %s value in config. " % constants.READER_CLASS_KEY
            #self.logger.error(msg)
            raise ValueError(msg)
        klass = globals().get(classname)
        #self.logger.debug("Created instance of %s" % classname)
        return klass(config, schema)
