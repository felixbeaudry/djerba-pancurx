"""
- Parse contents of the report directory generated by singleSample.r
- Output as JSON; this is a first step towards replacing the directory with a JSON file
- JSON output contains all necessary data for the HTML report (by definition);
but is not compliant with the Elba schema
"""

import csv
import json
import logging
import os
import djerba.util.constants as constants
import djerba.util.ini_fields as ini
from djerba.util.logger import logger

class report_directory_parser(logger):

    # files in report directory
    DATA_CLINICAL = 'data_clinical.txt'
    DATA_CNA_ONCOKBGENES_NONDIPLOID_ANNOTATED = 'data_CNA_oncoKBgenes_nonDiploid_annotated.txt'
    DATA_CNA_ONCOKBGENES_NONDIPLOID = 'data_CNA_oncoKBgenes_nonDiploid.txt'
    DATA_CNA = 'data_CNA.txt'
    DATA_EXPRESSION_PERCENTILE_COMPARISON = 'data_expression_percentile_comparison.txt'
    DATA_EXPRESSION_PERCENTILE_TCGA = 'data_expression_percentile_tcga.txt'
    DATA_EXPRESSION_ZSCORES_COMPARISON = 'data_expression_zscores_comparison.txt'
    DATA_EXPRESSION_ZSCORES_TCGA = 'data_expression_zscores_tcga.txt'
    DATA_FUSIONS_ONCOKB_ANNOTATED = 'data_fusions_oncokb_annotated.txt'
    DATA_FUSIONS = 'data_fusions.txt'
    DATA_LOG2CNA = 'data_log2CNA.txt'
    DATA_MUTATIONS_EXTENDED_ONCOGENIC = 'data_mutations_extended_oncogenic.txt'
    DATA_MUTATIONS_EXTENDED = 'data_mutations_extended.txt'
    DATA_SEGMENTS = 'data_segments.txt'
    GENOMIC_SUMMARY = 'genomic_summary.txt'
    SIGS = 'sigs'

    ALL_CONTENTS = [
        DATA_CLINICAL, 
        DATA_CNA_ONCOKBGENES_NONDIPLOID_ANNOTATED, 
        DATA_CNA_ONCOKBGENES_NONDIPLOID, 
        DATA_CNA, 
        DATA_EXPRESSION_PERCENTILE_COMPARISON, 
        DATA_EXPRESSION_PERCENTILE_TCGA, 
        DATA_EXPRESSION_ZSCORES_COMPARISON, 
        DATA_EXPRESSION_ZSCORES_TCGA, 
        DATA_FUSIONS_ONCOKB_ANNOTATED, 
        DATA_FUSIONS, 
        DATA_LOG2CNA, 
        DATA_MUTATIONS_EXTENDED_ONCOGENIC, 
        DATA_MUTATIONS_EXTENDED, 
        DATA_SEGMENTS, 
        GENOMIC_SUMMARY, 
        SIGS
    ]
    
    def __init__(self, report_dir, log_level=logging.WARN, log_path=None):
        self.report_dir = report_dir
        self.logger = self.get_logger(log_level, __name__, log_path)
        for filename in self.ALL_CONTENTS:
            if not os.path.exists(os.path.join(self.report_dir, filename)):
                msg = "Reporting file {0} not found in {1}".format(filename, self.report_dir)
                self.logger.error(msg)
                raise OSError(msg)
        total = len(self.ALL_CONTENTS)
        msg = "{0} required files found in reporting directory {1}".format(total, self.report_dir)
        self.logger.debug(msg)
        self.summary = {}
        self.summary[self.DATA_CLINICAL] = self.read_clinical_data(os.path.join(report_dir, self.DATA_CLINICAL))

    def get_summary(self):
        return self.summary

    def read_clinical_data(self, in_path):
        with open(in_path) as in_file:
            reader = csv.reader(in_file, delimiter="\t")
            i = 0
            for row in reader:
                if i==0:
                    header = row
                elif i==1:
                    body = row
                else:
                    msg = "Too many lines in clinical data file {0}".format(in_path)
                    self.logger.error(msg)
                    raise ValueError(msg)
                i += 1
        if len(header)!=len(body):
            msg = "Mismatched header/body lengths in clinical data file {0}".format(in_path)
            self.logger.error(msg)
            raise ValueError(msg)
        data = {}
        for i in range(len(header)):
            data[header[i]] = body[i]
        data[ini.MEAN_COVERAGE] = int(data[ini.MEAN_COVERAGE])
        for key in [ini.PCT_V7_ABOVE_80X, constants.SEQUENZA_PLOIDY_KEY, constants.SEQUENZA_PURITY_KEY]:
            data[key] = float(data[key])
        self.logger.debug("Read clinical data from {0}".format(in_path))
        return data

    def write_json(self, out_path):
        with open(out_path, 'w') as out_file:
            out_file.write(json.dumps(self.summary, indent=4, sort_keys='true'))
