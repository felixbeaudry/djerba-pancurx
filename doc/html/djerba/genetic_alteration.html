<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>djerba.genetic_alteration API documentation</title>
<meta name="description" content="Source of input data for Djerba; corresponds to the genetic_alteration_type metadata field in cBioPortal â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>djerba.genetic_alteration</code></h1>
</header>
<section id="section-intro">
<p>Source of input data for Djerba; corresponds to the genetic_alteration_type metadata field in cBioPortal.</p>
<p>A <code><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></code> object reads input from files, database queries, etc.; parses sample-level and gene-level attributes; and returns them in standard data structures.</p>
<p>Includes:</p>
<ul>
<li><code>genetic alteration</code>: Abstract base class</li>
<li>Subclasses to implement genetic_alteration methods for particular data types</li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration_factory" href="#djerba.genetic_alteration.genetic_alteration_factory">genetic_alteration_factory</a></code>: Class to construct an instance of an appropriate <code><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></code> subclass, given its name and other configuration data.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Source of input data for Djerba; corresponds to the genetic_alteration_type metadata field in cBioPortal.

A `genetic_alteration` object reads input from files, database queries, etc.; parses sample-level and gene-level attributes; and returns them in standard data structures.

Includes:

- `genetic alteration`: Abstract base class
- Subclasses to implement genetic_alteration methods for particular data types
- `genetic_alteration_factory`: Class to construct an instance of an appropriate `genetic_alteration` subclass, given its name and other configuration data.
&#34;&#34;&#34;

import logging
import os
import pandas as pd
import random
import re
import tempfile
import yaml
from djerba.metrics import mutation_extended_gene_metrics, mutation_extended_sample_metrics
from djerba.utilities import constants
from djerba.utilities.base import base
from djerba.utilities.tools import system_tools

class genetic_alteration(base):
    &#34;&#34;&#34;Base class; unit of genetic alteration data for cBioPortal and other reports&#34;&#34;&#34;

    # TODO make into a Python AbstractBaseClass: https://docs.python.org/3/library/abc.html

    # top-level config keys
    WORKFLOW_RUN_ID_KEY = &#39;workflow_run_id&#39;
    METADATA_KEY = &#39;metadata&#39;
    INPUT_FILES_KEY = &#39;input_files&#39;
    INPUT_DIRECTORY_KEY = &#39;input_directory&#39;
    # additional metadata keys
    FILTER_VCF_KEY = &#39;filter_vcf&#39;
    REGIONS_BED_KEY = &#39;regions_bed&#39;
    
    def __init__(self, config, study_id=None, log_level=logging.WARNING, log_path=None):
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)
        self.log_path = log_path
        self.study_id = study_id # required for cBioPortal, not for Elba
        try:
            self.genetic_alteration_type = config[constants.GENETIC_ALTERATION_TYPE_KEY]
            self.datatype = config[constants.DATATYPE_KEY]
            self.metadata = config[self.METADATA_KEY]
            self.input_files = config[self.INPUT_FILES_KEY]
            self.input_directory = config[self.INPUT_DIRECTORY_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        self.workflow_run_id = config.get(self.WORKFLOW_RUN_ID_KEY, None) # optional param
        self.sample_ids = self._get_sample_ids()
        self.sample_attributes = self._find_all_sample_attributes()
        # identifier for the genetic_alteration; should be unique in any given config
        self.alteration_id = &#34;%s:%s&#34; % (self.genetic_alteration_type, self.datatype)
        self.gene_names = None # used to cache the gene names

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;PLACEHOLDER. Read self.input_files and populate a sample attributes dictionary&#34;&#34;&#34;
        msg = &#34;_find_all_sample_attributes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        attributes = {}
        for sample_id in self.sample_ids:
            attributes[sample_id] = {}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;
        Find the list of sample IDs. Assumes the input_files config is non-empty.
        Optionally, can override this method in child classes.
        &#34;&#34;&#34;
        return sorted(self.input_files.keys())

    def _validate_gene_ids(self, existing_metrics, new_metrics, require_consistent=True):
        &#34;&#34;&#34;
        Check gene ID sets are consistent; if not, raise a warning or error
        Inputs are the dictionaries of metrics for all genes, or None for existing_metrics
        Nothing happens if:
        - existing_metrics are None: First in a series of updates
        - existing_metrics or new_metrics are empty: No gene-level metrics are defined
        &#34;&#34;&#34;
        if existing_metrics and len(existing_metrics)&gt;0 and len(new_metrics)&gt;0 and \
           set(existing_metrics.keys()) != set(new_metrics.keys()):
            msg = &#34;Inconsistent gene names in genetic alteration update; &#34;+\
                  &#34;run with debug logging for complete list. &#34;
            existing_genes = str(sorted(list(existing_metrics.keys())))
            new_genes = str(sorted(list(new_metrics.keys())))
            debug_msg = &#34;Inconsistent gene names: Expected %s, found %s&#34; % (existing_genes, new_genes)
            self.logger.debug(debug_msg)
            if require_consistent:
                msg += &#34;Consistent name requirement is in effect; raising an error.&#34;
                self.logger.error(msg)
                raise RuntimeError(msg)
            else:
                msg += &#34;Consistent name requirement is not in effect; continuing.&#34;
                self.logger.warning(msg)

    def _validate_metric_names(self, existing_name_set, new_name_set, require_consistent=True):
        &#34;&#34;&#34;
        Check that metric name sets are consistent; if not, raise a warning or error.
        Inputs are the sets of metric names, or None for existing_name_set
        If existing_name_set is None (eg. first update in a list), nothing happens
        &#34;&#34;&#34;
        if existing_name_set and existing_name_set != new_name_set:
            old_names = str(sorted(list(existing_name_set)))
            new_names = str(sorted(list(new_name_set)))
            msg = &#34;Gene metric name sets %s and %s are inconsistent. &#34; % (old_names, new_names)
            if require_consistent:
                msg += &#34;Consistent name requirement is in effect; raising an error.&#34;
                self.logger.error(msg)
                raise RuntimeError(msg)
            else:
                msg += &#34;Consistent name requirement is not in effect; continuing.&#34;
                self.logger.warning(msg)

    def get_alteration_id(self):
        &#34;&#34;&#34;ID defined as &#39;alteration_type:datatype&#39;, eg. &#39;MUTATION_EXTENDED:MAF&#39;&#34;&#34;&#34;
        return self.alteration_id

    def get_attributes_for_sample(self, sample_id):
        &#34;&#34;&#34;Find attributes for given sample_id.&#34;&#34;&#34;
        return self.sample_attributes[sample_id]

    def get_datatype(self):
        return self.datatype

    def get_genetic_alteration_type(self):
        return self.genetic_alteration_type

    def get_gene_names(self):
        &#34;&#34;&#34;
        PLACEHOLDER. Get a list of gene names from the input files.
        Not run from __init__() because it can be quite slow (eg. reading multiple MAF files).
        &#34;&#34;&#34;
        msg = &#34;get_genes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        raise RuntimeError(msg)

    def get_input_path(self, sample_id):
        return os.path.join(self.input_directory, self.input_files[sample_id])
    
    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.&#34;&#34;&#34;
        msg = &#34;get_metrics_by_gene method of parent class; not intended for production&#34;
        self.logger.error(msg)
        raise RuntimeError(msg)

    def get_sample_ids(self):
        return self.sample_ids

    def update_gene_metrics(self, metrics, sample_id, require_consistent=True, overwrite=False):
        &#34;&#34;&#34;
        Update the gene metrics dictionary
        If overwrite is True, replace any existing values for a metric with new ones
        If require_consistent is True:
        - Check all genes have the same set of metric names
        - Check the old and new metric sets have the same set of gene IDs
        &#34;&#34;&#34;
        new_metrics_by_gene = self.get_metrics_by_gene(sample_id)
        self._validate_gene_ids(metrics, new_metrics_by_gene, require_consistent)
        expected_names = None
        total_genes = len(new_metrics_by_gene)
        self.logger.debug(&#34;Updating metrics for %i genes on sample %s&#34; % (total_genes, sample_id))
        for gene_id in new_metrics_by_gene.keys():
            # update existing metrics (if any) with new ones
            existing_metrics = metrics.get(gene_id)
            new_metrics = new_metrics_by_gene.get(gene_id)
            if existing_metrics: # existing metrics found, update with new values
                before = len(existing_metrics)
                if overwrite:
                    # for any existing metric names, overwrite old values with new ones
                    existing_metrics.update(new_metrics)
                else:
                    # check metrics to avoid overwriting
                    shared_set = set(existing_metrics.keys()).intersection(set(new_metrics.keys()))
                    if len(shared_set) &gt; 0:
                        shared = &#39;, &#39;.join(sorted(list(shared_set)))
                        msg = &#34;Multiple gene-level metric values found for sample &#34;+\
                              &#34;%s, gene %s, metric(s): %s. &#34; % (sample_id, gene_id, shared) +\
                              &#34;Overwrite mode is not in effect.&#34;
                        self.logger.error(msg)
                        raise RuntimeError(msg)
                    else:
                        existing_metrics.update(new_metrics)
                updated_metrics = existing_metrics
                after = len(updated_metrics)
                self.logger.debug(&#34;Updated from %i to %i metrics for gene %s &#34; % (before, after, gene_id))
            else: # no existing metrics
                updated_metrics = new_metrics
            # check the metric names for consistency with previous genes
            updated_names = set(updated_metrics.keys())
            self._validate_metric_names(expected_names, updated_names, require_consistent)
            expected_names = updated_names
            metrics[gene_id] = updated_metrics
        return metrics

class genetic_alteration_factory(base):
    &#34;&#34;&#34;Supply an instance of the appropriate genetic_alteration subclass for an ALTERATIONTYPE&#34;&#34;&#34;

    CLASSNAMES = {
        constants.CUSTOM_ANNOTATION_TYPE: &#39;custom_annotation&#39;,
        constants.MUTATION_TYPE: &#39;mutation_extended&#39;,
        constants.SEGMENTED_TYPE: &#39;segmented&#39;
    }

    def __init__(self, log_level=logging.WARN, log_path=None):
        self.log_level = log_level
        self.log_path = log_path
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)

    def create_instance(self, config, study_id=None):
        &#34;&#34;&#34;Return an instance of the genetic_alteration class named in the config&#34;&#34;&#34;
        alteration_type = config.get(constants.GENETIC_ALTERATION_TYPE_KEY)
        classname = self.CLASSNAMES.get(alteration_type)
        if alteration_type == None or classname == None:
            msg = &#34;Unknown or missing %s value in config. &#34; % constants.GENETIC_ALTERATION_TYPE_KEY
            msg = msg+&#34; Permitted values are: %s&#34; % str(sorted(list(self.CLASSNAMES.keys())))
            self.logger.error(msg)
            raise ValueError(msg)
        klass = globals().get(classname)
        self.logger.debug(&#34;Created instance of %s&#34; % classname)
        return klass(config, study_id, self.log_level, self.log_path)

class custom_annotation(genetic_alteration):
    &#34;&#34;&#34;
    User-defined custom annotation supplied in TSV format.

    ## Input requirements

    - Input is in separate TSV files for gene and sample annotation.
    - Gene and sample filenames are specified in metadata, as &#39;gene_tsv&#39; and &#39;sample_tsv&#39; respectively.
    - Input files are tab-delimited, and may include comment lines starting with #.
    - Annotations which contain tab characters may be enclosed in double quotes (&#34;).
    - Column headers in the gene and sample files must be specified in config metadata, as &#39;gene_headers&#39; and &#39;sample_headers&#39; respectively.
    - The first column must be the gene or sample identifier, with header &#39;Gene&#39; or &#39;SAMPLE_ID&#39; respectively.
    - If column headers from metadata are not found in the TSV file, it will raise an error.
    - Columns in the TSV file which do not appear in metadata are silently ignored.

    ## Notes

    - Useful as a fallback for fields which cannot be automatically obtained by Djerba.
    - Currently supports Elba output only, not cBioPortal.
    &#34;&#34;&#34;

    GENE_HEADERS_KEY = &#39;gene_headers&#39;
    GENE_TSV_KEY = &#39;gene_tsv&#39;
    SAMPLE_HEADERS_KEY = &#39;sample_headers&#39;
    SAMPLE_TSV_KEY = &#39;sample_tsv&#39;

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;Read attributes for each sample from a TSV file with specified headers&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
            column_headers = self.metadata[self.SAMPLE_HEADERS_KEY] # must start with SAMPLE_ID_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        if column_headers[0] != constants.SAMPLE_ID_KEY:
            msg = &#34;First sample column header in metadata must be %s&#34; % constants.SAMPLE_ID_KEY
            self.logger.error(msg)
            raise ValueError(msg)
        attributes = {}
        df = self._read_columns(tsv_path, column_headers, constants.SAMPLE_ID_KEY)
        keys = df.columns.values.tolist() # use df instead of column_headers, to preserve column order
        for (sample_id, row) in df.iterrows():
            # row.to_list() is a workaround for int64 conversion; see comments in get_metrics_by_gene
            values = row.to_list()
            attributes[sample_id] = {keys[i]: values[i] for i in range(len(values))}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;Read sample IDs from TSV input file; overrides method of parent class&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.SAMPLE_ID_KEY], None, index_col=False)
        return df[constants.SAMPLE_ID_KEY].tolist()

    def _read_columns(self, input_path, column_headers, index_name, index_col=0):
        &#34;&#34;&#34;
        Read specified columns from TSV into a Pandas DataFrame.
        Raise an error if any requested columns are missing; warn if any values are null.
        index_col is the parameter of the same name for Pandas read_csv().
        index_name is the expected name of the index column; must be None if index_col=False.
        &#34;&#34;&#34;
        try:
            df = pd.read_csv(
                input_path,
                delimiter=&#34;\t&#34;,
                comment=&#34;#&#34;,
                index_col=index_col,
                usecols=column_headers
            )
        except ValueError as err:
            msg = &#39;Failed to read TSV from &#34;{0}&#34;. Missing required column headers &#39;.format(input_path) +\
                  &#39;from Djerba config? Pandas error message: &#34;{0}&#34;&#39;.format(err)
            self.logger.error(msg)
            raise
        if df.isnull().values.any():
            self.logger.info(
                &#39;Null values in TSV data read from &#34;{0}&#34; &#39;.format(input_path)+\
                &#39;with column headers {0}&#39;.format(str(column_headers))
            )
        if index_col is False and index_name!=None: # 0 has truth-value False, so use &#39;is&#39; instead of &#39;==&#39;
            msg = &#34;index_name must be None if index_col is False&#34;
            self.logger.error(msg)
            raise ValueError(msg)
        elif df.index.name != index_name:
            msg = &#34;First column header in %s: Expected %s, found %s&#34; % \
                  (input_path, index_name, df.index.name)
            self.logger.error(msg)
            raise ValueError(msg)
        return df

    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from TSV input file&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.GENE_KEY], None, index_col=False)
        return df[constants.GENE_KEY].tolist()

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Read gene-level metrics from input TSV.&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
            column_headers = self.metadata[self.GENE_HEADERS_KEY] # must start with GENE_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        if column_headers[0] != constants.GENE_KEY:
            msg = &#34;First gene column header in metadata must be %s&#34; % constants.GENE_KEY
            self.logger.error(msg)
            raise ValueError(msg)
        metrics_by_gene = {}
        df = self._read_columns(tsv_path, column_headers, constants.GENE_KEY)
        for (gene_name, row) in df.iterrows():
            # Can&#39;t use row.get() because this may return an int64, which can&#39;t be serialized to JSON
            # row.to_list() converts all values to Python scalars, so can be used as a workaround
            # See https://bugs.python.org/issue24313
            values = row.to_list()
            metrics_by_gene[gene_name] = {column_headers[i+1]: values[i] for i in range(len(values))}
        return metrics_by_gene

class mutation_extended(genetic_alteration):
    &#34;&#34;&#34;
    Represents the MUTATION_EXTENDED genetic alteration type in cBioPortal.
    Generates reports for either cBioPortal or Elba.
    &#34;&#34;&#34;

    DATA_FILENAME = &#39;data_mutation_extended.maf&#39;
    META_FILENAME = &#39;meta_mutation_extended.txt&#39;
    BED_PATH_KEY = &#39;bed_path&#39;
    TCGA_PATH_KEY = &#39;tcga_path&#39;
    CANCER_TYPE_KEY = &#39;cancer_type&#39;

    def _find_all_sample_attributes(self):
        # TODO &#39;cancer_type&#39; appears in study-level config. Could read it from there and
        # insert into the genetic_alteration config structure, instead of having duplicate
        # values in the study-level JSON config.
        try:
            bed_path = os.path.join(self.input_directory, self.metadata[self.BED_PATH_KEY])
            tcga_path = os.path.join(self.input_directory, self.metadata[self.TCGA_PATH_KEY])
            cancer_type = self.metadata[self.CANCER_TYPE_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        attributes = {}
        for sample_id in self.sample_ids:
            maf_path = os.path.join(self.input_directory, self.input_files[sample_id])
            mx_metrics = mutation_extended_sample_metrics(
                maf_path,
                bed_path,
                tcga_path,
                cancer_type,
                self.logger.getEffectiveLevel(),
                self.log_path
            )
            sample_attributes = {
                constants.TMB_PER_MB_KEY: mx_metrics.get_tmb(),
                constants.COSMIC_SIGS_KEY: mx_metrics.get_cosmic_sigs()
            }
            attributes[sample_id] = sample_attributes
        return attributes
    
    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from the input MAF files&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        gene_name_set = set()
        for sample_id in self.sample_ids:
            # pandas read_csv() will automatically decompress .gz input
            self.logger.debug(&#34;Reading gene names from %s/%s&#34; % (self.input_directory, input_file))
            df = pd.read_csv(
                self.get_input_path(sample_id),
                delimiter=&#34;\t&#34;,
                usecols=[self.HUGO_SYMBOL],
                comment=&#34;#&#34;
            )
            sample_gene_names = set(df[self.HUGO_SYMBOL].tolist())
            if len(gene_name_set) == 0:
                gene_name_set = sample_gene_names
            elif sample_gene_names != gene_name_set:
                self.logger.warning(&#34;Gene name sets are not consistent between input MAF files&#34;)
        # convert to list and sort
        gene_names = sorted(list(gene_name_set))
        self.gene_names = gene_names # store the gene names in case needed later
        return gene_names

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;
        Find gene-level mutation fields using the mutation_extended_gene_metrics class:
        - Gene
        - Chromosome
        - Protein Change
        - Variant Reads And Total Reads
        - Allele Fraction Percentile
        - OncoKB
        - FDA Approved Treatment
        &#34;&#34;&#34;
        self.logger.debug(&#34;Finding mutation_extended gene metrics&#34;)
        return mutation_extended_gene_metrics(
            self.get_input_path(sample_id),
            self.logger.getEffectiveLevel(),
            self.log_path
        ).get_metrics()

    def write_data(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation data table.

        - Read mutation data in MAF format and output in cBioPortal&#39;s required MAF format
        - May enable VCF input at a later date
        - see https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data
        - required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13
        &#34;&#34;&#34;
        tmp = tempfile.TemporaryDirectory(prefix=&#39;djerba_mutex_&#39;)
        tmp_dir = tmp.name
        #tmp_dir = &#39;/scratch2/users/ibancarz/djerba_test/latest&#39; # temporary location for testing
        input_paths = [os.path.join(self.input_directory, name) for name in self.input_files.values()]
        uncompressed = system_tools.decompress_gzip(input_paths, tmp_dir)
        commands = []
        output_paths = []
        for input_name in uncompressed:
            in_path = os.path.join(tmp_dir, input_name)
            out_path = os.path.join(tmp_dir, &#39;cbioportal.{}&#39;.format(input_name))
            cmd = &#34;maf2maf &#34;+\
                  &#34;--input-maf {} &#34;.format(in_path)+\
                  &#34;--output-maf {} &#34;.format(out_path)+\
                  &#34;--ref-fasta ${HG19_ROOT}/hg19_random.fa &#34;+\
                  &#34;--vep-path ${VEP_ROOT}/bin &#34;+\
                  &#34;--vep-data ${VEP_HG19_CACHE_ROOT}/.vep &#34;+\
                  &#34;--filter-vcf &#34;+self.metadata.get(self.FILTER_VCF_KEY)
            commands.append(cmd)
            output_paths.append(out_path)
        # run the maf2maf commands
        system_tools.run_subprocesses(commands, self.logger)
        # concatenate the outputs by appending to a pandas DataFrame
        output_df = pd.read_csv(output_paths[0], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
        self.logger.debug(&#34;Read %s dataframe from %s&#34; % (str(output_df.shape), output_paths[0]))
        for i in range(1, len(output_paths)):
            self.logger.debug(&#34;Appending %s dataframe from %s&#34; % (str(output_df.shape), output_paths[i]))
            next_output = pd.read_csv(output_paths[i], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
            output_df = output_df.append(next_output)
        self.logger.debug(&#34;Dimensions of output dataframe are %s&#34; % str(output_df.shape))
        out_path = os.path.join(out_dir, self.DATA_FILENAME)
        self.logger.info(&#34;Writing concatenated MAF output to %s&#34; % out_path)
        output_df.to_csv(out_path, sep=&#34;\t&#34;)
        tmp.cleanup()

    def write_meta(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation metadata.&#34;&#34;&#34;
        try:
            meta = {
                constants.STUDY_ID_KEY: self.study_id,
                constants.GENETIC_ALTERATION_TYPE_KEY: constants.MUTATION_TYPE,
                constants.DATATYPE_KEY: &#39;MAF&#39;,
                constants.STABLE_ID_KEY: &#39;mutations&#39;,
                constants.SHOW_PROFILE_IN_ANALYSIS_TAB_KEY: True,
                constants.PROFILE_NAME_KEY: self.metadata[constants.PROFILE_NAME_KEY],
                constants.PROFILE_DESCRIPTION_KEY: self.metadata[constants.PROFILE_DESCRIPTION_KEY],
                constants.DATA_FILENAME_KEY: self.DATA_FILENAME,
            }
            # omitting optional meta keys for now:
            # - gene_panel
            # - swissprot_identifier
            # - variant_classification_filter
            # - namespaces
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        with open(os.path.join(out_dir, self.META_FILENAME), &#39;w&#39;) as out_file:
            out_file.write(yaml.dump(meta, sort_keys=True))

    def write(self, out_dir):
        self.write_data(out_dir)
        self.write_meta(out_dir)

class segmented(genetic_alteration):
    &#34;&#34;&#34;
    Segmented data format from cBioPortal; input is SEG files.

    Currently supports Elba output only, not cBioPortal.
    &#34;&#34;&#34;

    MINIMUM_ABS_SEG_MEAN = 0.2

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;Find FGA for each SEG file&#34;&#34;&#34;
        attributes = {}
        for sample_id in self.sample_ids:
            seg_path = os.path.join(self.input_directory, self.input_files[sample_id])
            sample_attributes = {
                constants.FRACTION_GENOME_ALTERED_KEY: self._find_fga(seg_path, sample_id)
            }
            attributes[sample_id] = sample_attributes
        return attributes

    def _find_fga(self, seg_path, sample_id):
        seg = pd.read_csv(seg_path, sep=&#39;\t&#39;, skiprows= 0)
        # ID column of .seg file may be of the form ${SAMPLE_ID}.tumour.bam.varscanSomatic
        # Match against $SAMPLE_ID, followed by end-of-string OR a dot followed by a word character
        # Escape the $SAMPLE_ID in case it contains regex metacharacters
        # This will not catch pathological cases, eg. two samples with respective IDs &#34;foo&#34; and &#34;foo.bar&#34;
        seg_sample = seg.loc[seg.ID.str.match(re.escape(sample_id)+&#34;(\.\w|$)&#34;)]
        seg_alt = seg_sample.loc[abs(seg_sample[&#34;seg.mean&#34;]) &gt; self.MINIMUM_ABS_SEG_MEAN]
        denom = sum(seg_sample[&#39;loc.end&#39;] - seg_sample[&#39;loc.start&#39;])
        try:
            fga = sum(seg_alt[&#39;loc.end&#39;] - seg_alt[&#39;loc.start&#39;])/denom
        except ZeroDivisionError:
            self.logger.warning(&#39;FGA interval has zero width; FRACTION_GENOME_ALTERED is NA&#39;)
            fga = &#34;NA&#34;
        return fga

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Return an empty dictionary, because SEG data has no gene-level metrics&#34;&#34;&#34;
        self.logger.debug(&#34;SEG data has no gene-level metrics, only sample-level; returning empty dictionary&#34;)
        return {}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="djerba.genetic_alteration.custom_annotation"><code class="flex name class">
<span>class <span class="ident">custom_annotation</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>User-defined custom annotation supplied in TSV format.</p>
<h2 id="input-requirements">Input requirements</h2>
<ul>
<li>Input is in separate TSV files for gene and sample annotation.</li>
<li>Gene and sample filenames are specified in metadata, as 'gene_tsv' and 'sample_tsv' respectively.</li>
<li>Input files are tab-delimited, and may include comment lines starting with #.</li>
<li>Annotations which contain tab characters may be enclosed in double quotes (").</li>
<li>Column headers in the gene and sample files must be specified in config metadata, as 'gene_headers' and 'sample_headers' respectively.</li>
<li>The first column must be the gene or sample identifier, with header 'Gene' or 'SAMPLE_ID' respectively.</li>
<li>If column headers from metadata are not found in the TSV file, it will raise an error.</li>
<li>Columns in the TSV file which do not appear in metadata are silently ignored.</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>Useful as a fallback for fields which cannot be automatically obtained by Djerba.</li>
<li>Currently supports Elba output only, not cBioPortal.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class custom_annotation(genetic_alteration):
    &#34;&#34;&#34;
    User-defined custom annotation supplied in TSV format.

    ## Input requirements

    - Input is in separate TSV files for gene and sample annotation.
    - Gene and sample filenames are specified in metadata, as &#39;gene_tsv&#39; and &#39;sample_tsv&#39; respectively.
    - Input files are tab-delimited, and may include comment lines starting with #.
    - Annotations which contain tab characters may be enclosed in double quotes (&#34;).
    - Column headers in the gene and sample files must be specified in config metadata, as &#39;gene_headers&#39; and &#39;sample_headers&#39; respectively.
    - The first column must be the gene or sample identifier, with header &#39;Gene&#39; or &#39;SAMPLE_ID&#39; respectively.
    - If column headers from metadata are not found in the TSV file, it will raise an error.
    - Columns in the TSV file which do not appear in metadata are silently ignored.

    ## Notes

    - Useful as a fallback for fields which cannot be automatically obtained by Djerba.
    - Currently supports Elba output only, not cBioPortal.
    &#34;&#34;&#34;

    GENE_HEADERS_KEY = &#39;gene_headers&#39;
    GENE_TSV_KEY = &#39;gene_tsv&#39;
    SAMPLE_HEADERS_KEY = &#39;sample_headers&#39;
    SAMPLE_TSV_KEY = &#39;sample_tsv&#39;

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;Read attributes for each sample from a TSV file with specified headers&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
            column_headers = self.metadata[self.SAMPLE_HEADERS_KEY] # must start with SAMPLE_ID_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        if column_headers[0] != constants.SAMPLE_ID_KEY:
            msg = &#34;First sample column header in metadata must be %s&#34; % constants.SAMPLE_ID_KEY
            self.logger.error(msg)
            raise ValueError(msg)
        attributes = {}
        df = self._read_columns(tsv_path, column_headers, constants.SAMPLE_ID_KEY)
        keys = df.columns.values.tolist() # use df instead of column_headers, to preserve column order
        for (sample_id, row) in df.iterrows():
            # row.to_list() is a workaround for int64 conversion; see comments in get_metrics_by_gene
            values = row.to_list()
            attributes[sample_id] = {keys[i]: values[i] for i in range(len(values))}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;Read sample IDs from TSV input file; overrides method of parent class&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.SAMPLE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.SAMPLE_ID_KEY], None, index_col=False)
        return df[constants.SAMPLE_ID_KEY].tolist()

    def _read_columns(self, input_path, column_headers, index_name, index_col=0):
        &#34;&#34;&#34;
        Read specified columns from TSV into a Pandas DataFrame.
        Raise an error if any requested columns are missing; warn if any values are null.
        index_col is the parameter of the same name for Pandas read_csv().
        index_name is the expected name of the index column; must be None if index_col=False.
        &#34;&#34;&#34;
        try:
            df = pd.read_csv(
                input_path,
                delimiter=&#34;\t&#34;,
                comment=&#34;#&#34;,
                index_col=index_col,
                usecols=column_headers
            )
        except ValueError as err:
            msg = &#39;Failed to read TSV from &#34;{0}&#34;. Missing required column headers &#39;.format(input_path) +\
                  &#39;from Djerba config? Pandas error message: &#34;{0}&#34;&#39;.format(err)
            self.logger.error(msg)
            raise
        if df.isnull().values.any():
            self.logger.info(
                &#39;Null values in TSV data read from &#34;{0}&#34; &#39;.format(input_path)+\
                &#39;with column headers {0}&#39;.format(str(column_headers))
            )
        if index_col is False and index_name!=None: # 0 has truth-value False, so use &#39;is&#39; instead of &#39;==&#39;
            msg = &#34;index_name must be None if index_col is False&#34;
            self.logger.error(msg)
            raise ValueError(msg)
        elif df.index.name != index_name:
            msg = &#34;First column header in %s: Expected %s, found %s&#34; % \
                  (input_path, index_name, df.index.name)
            self.logger.error(msg)
            raise ValueError(msg)
        return df

    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from TSV input file&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        df = self._read_columns(tsv_path, [constants.GENE_KEY], None, index_col=False)
        return df[constants.GENE_KEY].tolist()

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Read gene-level metrics from input TSV.&#34;&#34;&#34;
        try:
            tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
            column_headers = self.metadata[self.GENE_HEADERS_KEY] # must start with GENE_KEY
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        if column_headers[0] != constants.GENE_KEY:
            msg = &#34;First gene column header in metadata must be %s&#34; % constants.GENE_KEY
            self.logger.error(msg)
            raise ValueError(msg)
        metrics_by_gene = {}
        df = self._read_columns(tsv_path, column_headers, constants.GENE_KEY)
        for (gene_name, row) in df.iterrows():
            # Can&#39;t use row.get() because this may return an int64, which can&#39;t be serialized to JSON
            # row.to_list() converts all values to Python scalars, so can be used as a workaround
            # See https://bugs.python.org/issue24313
            values = row.to_list()
            metrics_by_gene[gene_name] = {column_headers[i+1]: values[i] for i in range(len(values))}
        return metrics_by_gene</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></li>
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.custom_annotation.GENE_HEADERS_KEY"><code class="name">var <span class="ident">GENE_HEADERS_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.GENE_TSV_KEY"><code class="name">var <span class="ident">GENE_TSV_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.SAMPLE_HEADERS_KEY"><code class="name">var <span class="ident">SAMPLE_HEADERS_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.SAMPLE_TSV_KEY"><code class="name">var <span class="ident">SAMPLE_TSV_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.custom_annotation.get_gene_names"><code class="name flex">
<span>def <span class="ident">get_gene_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gene names from TSV input file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_names(self):
    &#34;&#34;&#34;Find gene names from TSV input file&#34;&#34;&#34;
    if self.gene_names:
        return self.gene_names
    try:
        tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
    except KeyError as err:
        self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
        raise
    df = self._read_columns(tsv_path, [constants.GENE_KEY], None, index_col=False)
    return df[constants.GENE_KEY].tolist()</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.custom_annotation.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Read gene-level metrics from input TSV.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;Read gene-level metrics from input TSV.&#34;&#34;&#34;
    try:
        tsv_path = os.path.join(self.input_directory, self.metadata[self.GENE_TSV_KEY])
        column_headers = self.metadata[self.GENE_HEADERS_KEY] # must start with GENE_KEY
    except KeyError as err:
        self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
        raise
    if column_headers[0] != constants.GENE_KEY:
        msg = &#34;First gene column header in metadata must be %s&#34; % constants.GENE_KEY
        self.logger.error(msg)
        raise ValueError(msg)
    metrics_by_gene = {}
    df = self._read_columns(tsv_path, column_headers, constants.GENE_KEY)
    for (gene_name, row) in df.iterrows():
        # Can&#39;t use row.get() because this may return an int64, which can&#39;t be serialized to JSON
        # row.to_list() converts all values to Python scalars, so can be used as a workaround
        # See https://bugs.python.org/issue24313
        values = row.to_list()
        metrics_by_gene[gene_name] = {column_headers[i+1]: values[i] for i in range(len(values))}
    return metrics_by_gene</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.is_null" href="utilities/base.html#djerba.utilities.base.base.is_null">is_null</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.update_gene_metrics" href="#djerba.genetic_alteration.genetic_alteration.update_gene_metrics">update_gene_metrics</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration"><code class="flex name class">
<span>class <span class="ident">genetic_alteration</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class; unit of genetic alteration data for cBioPortal and other reports</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genetic_alteration(base):
    &#34;&#34;&#34;Base class; unit of genetic alteration data for cBioPortal and other reports&#34;&#34;&#34;

    # TODO make into a Python AbstractBaseClass: https://docs.python.org/3/library/abc.html

    # top-level config keys
    WORKFLOW_RUN_ID_KEY = &#39;workflow_run_id&#39;
    METADATA_KEY = &#39;metadata&#39;
    INPUT_FILES_KEY = &#39;input_files&#39;
    INPUT_DIRECTORY_KEY = &#39;input_directory&#39;
    # additional metadata keys
    FILTER_VCF_KEY = &#39;filter_vcf&#39;
    REGIONS_BED_KEY = &#39;regions_bed&#39;
    
    def __init__(self, config, study_id=None, log_level=logging.WARNING, log_path=None):
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)
        self.log_path = log_path
        self.study_id = study_id # required for cBioPortal, not for Elba
        try:
            self.genetic_alteration_type = config[constants.GENETIC_ALTERATION_TYPE_KEY]
            self.datatype = config[constants.DATATYPE_KEY]
            self.metadata = config[self.METADATA_KEY]
            self.input_files = config[self.INPUT_FILES_KEY]
            self.input_directory = config[self.INPUT_DIRECTORY_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        self.workflow_run_id = config.get(self.WORKFLOW_RUN_ID_KEY, None) # optional param
        self.sample_ids = self._get_sample_ids()
        self.sample_attributes = self._find_all_sample_attributes()
        # identifier for the genetic_alteration; should be unique in any given config
        self.alteration_id = &#34;%s:%s&#34; % (self.genetic_alteration_type, self.datatype)
        self.gene_names = None # used to cache the gene names

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;PLACEHOLDER. Read self.input_files and populate a sample attributes dictionary&#34;&#34;&#34;
        msg = &#34;_find_all_sample_attributes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        attributes = {}
        for sample_id in self.sample_ids:
            attributes[sample_id] = {}
        return attributes

    def _get_sample_ids(self):
        &#34;&#34;&#34;
        Find the list of sample IDs. Assumes the input_files config is non-empty.
        Optionally, can override this method in child classes.
        &#34;&#34;&#34;
        return sorted(self.input_files.keys())

    def _validate_gene_ids(self, existing_metrics, new_metrics, require_consistent=True):
        &#34;&#34;&#34;
        Check gene ID sets are consistent; if not, raise a warning or error
        Inputs are the dictionaries of metrics for all genes, or None for existing_metrics
        Nothing happens if:
        - existing_metrics are None: First in a series of updates
        - existing_metrics or new_metrics are empty: No gene-level metrics are defined
        &#34;&#34;&#34;
        if existing_metrics and len(existing_metrics)&gt;0 and len(new_metrics)&gt;0 and \
           set(existing_metrics.keys()) != set(new_metrics.keys()):
            msg = &#34;Inconsistent gene names in genetic alteration update; &#34;+\
                  &#34;run with debug logging for complete list. &#34;
            existing_genes = str(sorted(list(existing_metrics.keys())))
            new_genes = str(sorted(list(new_metrics.keys())))
            debug_msg = &#34;Inconsistent gene names: Expected %s, found %s&#34; % (existing_genes, new_genes)
            self.logger.debug(debug_msg)
            if require_consistent:
                msg += &#34;Consistent name requirement is in effect; raising an error.&#34;
                self.logger.error(msg)
                raise RuntimeError(msg)
            else:
                msg += &#34;Consistent name requirement is not in effect; continuing.&#34;
                self.logger.warning(msg)

    def _validate_metric_names(self, existing_name_set, new_name_set, require_consistent=True):
        &#34;&#34;&#34;
        Check that metric name sets are consistent; if not, raise a warning or error.
        Inputs are the sets of metric names, or None for existing_name_set
        If existing_name_set is None (eg. first update in a list), nothing happens
        &#34;&#34;&#34;
        if existing_name_set and existing_name_set != new_name_set:
            old_names = str(sorted(list(existing_name_set)))
            new_names = str(sorted(list(new_name_set)))
            msg = &#34;Gene metric name sets %s and %s are inconsistent. &#34; % (old_names, new_names)
            if require_consistent:
                msg += &#34;Consistent name requirement is in effect; raising an error.&#34;
                self.logger.error(msg)
                raise RuntimeError(msg)
            else:
                msg += &#34;Consistent name requirement is not in effect; continuing.&#34;
                self.logger.warning(msg)

    def get_alteration_id(self):
        &#34;&#34;&#34;ID defined as &#39;alteration_type:datatype&#39;, eg. &#39;MUTATION_EXTENDED:MAF&#39;&#34;&#34;&#34;
        return self.alteration_id

    def get_attributes_for_sample(self, sample_id):
        &#34;&#34;&#34;Find attributes for given sample_id.&#34;&#34;&#34;
        return self.sample_attributes[sample_id]

    def get_datatype(self):
        return self.datatype

    def get_genetic_alteration_type(self):
        return self.genetic_alteration_type

    def get_gene_names(self):
        &#34;&#34;&#34;
        PLACEHOLDER. Get a list of gene names from the input files.
        Not run from __init__() because it can be quite slow (eg. reading multiple MAF files).
        &#34;&#34;&#34;
        msg = &#34;get_genes method of parent class; not intended for production&#34;
        self.logger.error(msg)
        raise RuntimeError(msg)

    def get_input_path(self, sample_id):
        return os.path.join(self.input_directory, self.input_files[sample_id])
    
    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.&#34;&#34;&#34;
        msg = &#34;get_metrics_by_gene method of parent class; not intended for production&#34;
        self.logger.error(msg)
        raise RuntimeError(msg)

    def get_sample_ids(self):
        return self.sample_ids

    def update_gene_metrics(self, metrics, sample_id, require_consistent=True, overwrite=False):
        &#34;&#34;&#34;
        Update the gene metrics dictionary
        If overwrite is True, replace any existing values for a metric with new ones
        If require_consistent is True:
        - Check all genes have the same set of metric names
        - Check the old and new metric sets have the same set of gene IDs
        &#34;&#34;&#34;
        new_metrics_by_gene = self.get_metrics_by_gene(sample_id)
        self._validate_gene_ids(metrics, new_metrics_by_gene, require_consistent)
        expected_names = None
        total_genes = len(new_metrics_by_gene)
        self.logger.debug(&#34;Updating metrics for %i genes on sample %s&#34; % (total_genes, sample_id))
        for gene_id in new_metrics_by_gene.keys():
            # update existing metrics (if any) with new ones
            existing_metrics = metrics.get(gene_id)
            new_metrics = new_metrics_by_gene.get(gene_id)
            if existing_metrics: # existing metrics found, update with new values
                before = len(existing_metrics)
                if overwrite:
                    # for any existing metric names, overwrite old values with new ones
                    existing_metrics.update(new_metrics)
                else:
                    # check metrics to avoid overwriting
                    shared_set = set(existing_metrics.keys()).intersection(set(new_metrics.keys()))
                    if len(shared_set) &gt; 0:
                        shared = &#39;, &#39;.join(sorted(list(shared_set)))
                        msg = &#34;Multiple gene-level metric values found for sample &#34;+\
                              &#34;%s, gene %s, metric(s): %s. &#34; % (sample_id, gene_id, shared) +\
                              &#34;Overwrite mode is not in effect.&#34;
                        self.logger.error(msg)
                        raise RuntimeError(msg)
                    else:
                        existing_metrics.update(new_metrics)
                updated_metrics = existing_metrics
                after = len(updated_metrics)
                self.logger.debug(&#34;Updated from %i to %i metrics for gene %s &#34; % (before, after, gene_id))
            else: # no existing metrics
                updated_metrics = new_metrics
            # check the metric names for consistency with previous genes
            updated_names = set(updated_metrics.keys())
            self._validate_metric_names(expected_names, updated_names, require_consistent)
            expected_names = updated_names
            metrics[gene_id] = updated_metrics
        return metrics</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.custom_annotation" href="#djerba.genetic_alteration.custom_annotation">custom_annotation</a></li>
<li><a title="djerba.genetic_alteration.mutation_extended" href="#djerba.genetic_alteration.mutation_extended">mutation_extended</a></li>
<li><a title="djerba.genetic_alteration.segmented" href="#djerba.genetic_alteration.segmented">segmented</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration.FILTER_VCF_KEY"><code class="name">var <span class="ident">FILTER_VCF_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.INPUT_DIRECTORY_KEY"><code class="name">var <span class="ident">INPUT_DIRECTORY_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.INPUT_FILES_KEY"><code class="name">var <span class="ident">INPUT_FILES_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.METADATA_KEY"><code class="name">var <span class="ident">METADATA_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.REGIONS_BED_KEY"><code class="name">var <span class="ident">REGIONS_BED_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.WORKFLOW_RUN_ID_KEY"><code class="name">var <span class="ident">WORKFLOW_RUN_ID_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration.get_alteration_id"><code class="name flex">
<span>def <span class="ident">get_alteration_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ID defined as 'alteration_type:datatype', eg. 'MUTATION_EXTENDED:MAF'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alteration_id(self):
    &#34;&#34;&#34;ID defined as &#39;alteration_type:datatype&#39;, eg. &#39;MUTATION_EXTENDED:MAF&#39;&#34;&#34;&#34;
    return self.alteration_id</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample"><code class="name flex">
<span>def <span class="ident">get_attributes_for_sample</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Find attributes for given sample_id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes_for_sample(self, sample_id):
    &#34;&#34;&#34;Find attributes for given sample_id.&#34;&#34;&#34;
    return self.sample_attributes[sample_id]</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_datatype"><code class="name flex">
<span>def <span class="ident">get_datatype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datatype(self):
    return self.datatype</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_gene_names"><code class="name flex">
<span>def <span class="ident">get_gene_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>PLACEHOLDER. Get a list of gene names from the input files.
Not run from <strong>init</strong>() because it can be quite slow (eg. reading multiple MAF files).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_names(self):
    &#34;&#34;&#34;
    PLACEHOLDER. Get a list of gene names from the input files.
    Not run from __init__() because it can be quite slow (eg. reading multiple MAF files).
    &#34;&#34;&#34;
    msg = &#34;get_genes method of parent class; not intended for production&#34;
    self.logger.error(msg)
    raise RuntimeError(msg)</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_genetic_alteration_type"><code class="name flex">
<span>def <span class="ident">get_genetic_alteration_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_genetic_alteration_type(self):
    return self.genetic_alteration_type</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_input_path"><code class="name flex">
<span>def <span class="ident">get_input_path</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_path(self, sample_id):
    return os.path.join(self.input_directory, self.input_files[sample_id])</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;PLACEHOLDER. Get a dictionary of metric values for the given sample, indexed by gene.&#34;&#34;&#34;
    msg = &#34;get_metrics_by_gene method of parent class; not intended for production&#34;
    self.logger.error(msg)
    raise RuntimeError(msg)</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.get_sample_ids"><code class="name flex">
<span>def <span class="ident">get_sample_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample_ids(self):
    return self.sample_ids</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration.update_gene_metrics"><code class="name flex">
<span>def <span class="ident">update_gene_metrics</span></span>(<span>self, metrics, sample_id, require_consistent=True, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the gene metrics dictionary
If overwrite is True, replace any existing values for a metric with new ones
If require_consistent is True:
- Check all genes have the same set of metric names
- Check the old and new metric sets have the same set of gene IDs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_gene_metrics(self, metrics, sample_id, require_consistent=True, overwrite=False):
    &#34;&#34;&#34;
    Update the gene metrics dictionary
    If overwrite is True, replace any existing values for a metric with new ones
    If require_consistent is True:
    - Check all genes have the same set of metric names
    - Check the old and new metric sets have the same set of gene IDs
    &#34;&#34;&#34;
    new_metrics_by_gene = self.get_metrics_by_gene(sample_id)
    self._validate_gene_ids(metrics, new_metrics_by_gene, require_consistent)
    expected_names = None
    total_genes = len(new_metrics_by_gene)
    self.logger.debug(&#34;Updating metrics for %i genes on sample %s&#34; % (total_genes, sample_id))
    for gene_id in new_metrics_by_gene.keys():
        # update existing metrics (if any) with new ones
        existing_metrics = metrics.get(gene_id)
        new_metrics = new_metrics_by_gene.get(gene_id)
        if existing_metrics: # existing metrics found, update with new values
            before = len(existing_metrics)
            if overwrite:
                # for any existing metric names, overwrite old values with new ones
                existing_metrics.update(new_metrics)
            else:
                # check metrics to avoid overwriting
                shared_set = set(existing_metrics.keys()).intersection(set(new_metrics.keys()))
                if len(shared_set) &gt; 0:
                    shared = &#39;, &#39;.join(sorted(list(shared_set)))
                    msg = &#34;Multiple gene-level metric values found for sample &#34;+\
                          &#34;%s, gene %s, metric(s): %s. &#34; % (sample_id, gene_id, shared) +\
                          &#34;Overwrite mode is not in effect.&#34;
                    self.logger.error(msg)
                    raise RuntimeError(msg)
                else:
                    existing_metrics.update(new_metrics)
            updated_metrics = existing_metrics
            after = len(updated_metrics)
            self.logger.debug(&#34;Updated from %i to %i metrics for gene %s &#34; % (before, after, gene_id))
        else: # no existing metrics
            updated_metrics = new_metrics
        # check the metric names for consistency with previous genes
        updated_names = set(updated_metrics.keys())
        self._validate_metric_names(expected_names, updated_names, require_consistent)
        expected_names = updated_names
        metrics[gene_id] = updated_metrics
    return metrics</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.utilities.base.base.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
<li><code><a title="djerba.utilities.base.base.is_null" href="utilities/base.html#djerba.utilities.base.base.is_null">is_null</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.genetic_alteration_factory"><code class="flex name class">
<span>class <span class="ident">genetic_alteration_factory</span></span>
<span>(</span><span>log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Supply an instance of the appropriate genetic_alteration subclass for an ALTERATIONTYPE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genetic_alteration_factory(base):
    &#34;&#34;&#34;Supply an instance of the appropriate genetic_alteration subclass for an ALTERATIONTYPE&#34;&#34;&#34;

    CLASSNAMES = {
        constants.CUSTOM_ANNOTATION_TYPE: &#39;custom_annotation&#39;,
        constants.MUTATION_TYPE: &#39;mutation_extended&#39;,
        constants.SEGMENTED_TYPE: &#39;segmented&#39;
    }

    def __init__(self, log_level=logging.WARN, log_path=None):
        self.log_level = log_level
        self.log_path = log_path
        self.logger = self.get_logger(log_level, &#34;%s.%s&#34; % (__name__, type(self).__name__), log_path)

    def create_instance(self, config, study_id=None):
        &#34;&#34;&#34;Return an instance of the genetic_alteration class named in the config&#34;&#34;&#34;
        alteration_type = config.get(constants.GENETIC_ALTERATION_TYPE_KEY)
        classname = self.CLASSNAMES.get(alteration_type)
        if alteration_type == None or classname == None:
            msg = &#34;Unknown or missing %s value in config. &#34; % constants.GENETIC_ALTERATION_TYPE_KEY
            msg = msg+&#34; Permitted values are: %s&#34; % str(sorted(list(self.CLASSNAMES.keys())))
            self.logger.error(msg)
            raise ValueError(msg)
        klass = globals().get(classname)
        self.logger.debug(&#34;Created instance of %s&#34; % classname)
        return klass(config, study_id, self.log_level, self.log_path)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration_factory.CLASSNAMES"><code class="name">var <span class="ident">CLASSNAMES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.genetic_alteration_factory.create_instance"><code class="name flex">
<span>def <span class="ident">create_instance</span></span>(<span>self, config, study_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an instance of the genetic_alteration class named in the config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_instance(self, config, study_id=None):
    &#34;&#34;&#34;Return an instance of the genetic_alteration class named in the config&#34;&#34;&#34;
    alteration_type = config.get(constants.GENETIC_ALTERATION_TYPE_KEY)
    classname = self.CLASSNAMES.get(alteration_type)
    if alteration_type == None or classname == None:
        msg = &#34;Unknown or missing %s value in config. &#34; % constants.GENETIC_ALTERATION_TYPE_KEY
        msg = msg+&#34; Permitted values are: %s&#34; % str(sorted(list(self.CLASSNAMES.keys())))
        self.logger.error(msg)
        raise ValueError(msg)
    klass = globals().get(classname)
    self.logger.debug(&#34;Created instance of %s&#34; % classname)
    return klass(config, study_id, self.log_level, self.log_path)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.utilities.base.base.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
<li><code><a title="djerba.utilities.base.base.is_null" href="utilities/base.html#djerba.utilities.base.base.is_null">is_null</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended"><code class="flex name class">
<span>class <span class="ident">mutation_extended</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the MUTATION_EXTENDED genetic alteration type in cBioPortal.
Generates reports for either cBioPortal or Elba.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mutation_extended(genetic_alteration):
    &#34;&#34;&#34;
    Represents the MUTATION_EXTENDED genetic alteration type in cBioPortal.
    Generates reports for either cBioPortal or Elba.
    &#34;&#34;&#34;

    DATA_FILENAME = &#39;data_mutation_extended.maf&#39;
    META_FILENAME = &#39;meta_mutation_extended.txt&#39;
    BED_PATH_KEY = &#39;bed_path&#39;
    TCGA_PATH_KEY = &#39;tcga_path&#39;
    CANCER_TYPE_KEY = &#39;cancer_type&#39;

    def _find_all_sample_attributes(self):
        # TODO &#39;cancer_type&#39; appears in study-level config. Could read it from there and
        # insert into the genetic_alteration config structure, instead of having duplicate
        # values in the study-level JSON config.
        try:
            bed_path = os.path.join(self.input_directory, self.metadata[self.BED_PATH_KEY])
            tcga_path = os.path.join(self.input_directory, self.metadata[self.TCGA_PATH_KEY])
            cancer_type = self.metadata[self.CANCER_TYPE_KEY]
        except KeyError as err:
            self.logger.error(&#34;Missing required metadata key: {0}&#34;.format(err))
            raise
        attributes = {}
        for sample_id in self.sample_ids:
            maf_path = os.path.join(self.input_directory, self.input_files[sample_id])
            mx_metrics = mutation_extended_sample_metrics(
                maf_path,
                bed_path,
                tcga_path,
                cancer_type,
                self.logger.getEffectiveLevel(),
                self.log_path
            )
            sample_attributes = {
                constants.TMB_PER_MB_KEY: mx_metrics.get_tmb(),
                constants.COSMIC_SIGS_KEY: mx_metrics.get_cosmic_sigs()
            }
            attributes[sample_id] = sample_attributes
        return attributes
    
    def get_gene_names(self):
        &#34;&#34;&#34;Find gene names from the input MAF files&#34;&#34;&#34;
        if self.gene_names:
            return self.gene_names
        gene_name_set = set()
        for sample_id in self.sample_ids:
            # pandas read_csv() will automatically decompress .gz input
            self.logger.debug(&#34;Reading gene names from %s/%s&#34; % (self.input_directory, input_file))
            df = pd.read_csv(
                self.get_input_path(sample_id),
                delimiter=&#34;\t&#34;,
                usecols=[self.HUGO_SYMBOL],
                comment=&#34;#&#34;
            )
            sample_gene_names = set(df[self.HUGO_SYMBOL].tolist())
            if len(gene_name_set) == 0:
                gene_name_set = sample_gene_names
            elif sample_gene_names != gene_name_set:
                self.logger.warning(&#34;Gene name sets are not consistent between input MAF files&#34;)
        # convert to list and sort
        gene_names = sorted(list(gene_name_set))
        self.gene_names = gene_names # store the gene names in case needed later
        return gene_names

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;
        Find gene-level mutation fields using the mutation_extended_gene_metrics class:
        - Gene
        - Chromosome
        - Protein Change
        - Variant Reads And Total Reads
        - Allele Fraction Percentile
        - OncoKB
        - FDA Approved Treatment
        &#34;&#34;&#34;
        self.logger.debug(&#34;Finding mutation_extended gene metrics&#34;)
        return mutation_extended_gene_metrics(
            self.get_input_path(sample_id),
            self.logger.getEffectiveLevel(),
            self.log_path
        ).get_metrics()

    def write_data(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation data table.

        - Read mutation data in MAF format and output in cBioPortal&#39;s required MAF format
        - May enable VCF input at a later date
        - see https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data
        - required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13
        &#34;&#34;&#34;
        tmp = tempfile.TemporaryDirectory(prefix=&#39;djerba_mutex_&#39;)
        tmp_dir = tmp.name
        #tmp_dir = &#39;/scratch2/users/ibancarz/djerba_test/latest&#39; # temporary location for testing
        input_paths = [os.path.join(self.input_directory, name) for name in self.input_files.values()]
        uncompressed = system_tools.decompress_gzip(input_paths, tmp_dir)
        commands = []
        output_paths = []
        for input_name in uncompressed:
            in_path = os.path.join(tmp_dir, input_name)
            out_path = os.path.join(tmp_dir, &#39;cbioportal.{}&#39;.format(input_name))
            cmd = &#34;maf2maf &#34;+\
                  &#34;--input-maf {} &#34;.format(in_path)+\
                  &#34;--output-maf {} &#34;.format(out_path)+\
                  &#34;--ref-fasta ${HG19_ROOT}/hg19_random.fa &#34;+\
                  &#34;--vep-path ${VEP_ROOT}/bin &#34;+\
                  &#34;--vep-data ${VEP_HG19_CACHE_ROOT}/.vep &#34;+\
                  &#34;--filter-vcf &#34;+self.metadata.get(self.FILTER_VCF_KEY)
            commands.append(cmd)
            output_paths.append(out_path)
        # run the maf2maf commands
        system_tools.run_subprocesses(commands, self.logger)
        # concatenate the outputs by appending to a pandas DataFrame
        output_df = pd.read_csv(output_paths[0], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
        self.logger.debug(&#34;Read %s dataframe from %s&#34; % (str(output_df.shape), output_paths[0]))
        for i in range(1, len(output_paths)):
            self.logger.debug(&#34;Appending %s dataframe from %s&#34; % (str(output_df.shape), output_paths[i]))
            next_output = pd.read_csv(output_paths[i], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
            output_df = output_df.append(next_output)
        self.logger.debug(&#34;Dimensions of output dataframe are %s&#34; % str(output_df.shape))
        out_path = os.path.join(out_dir, self.DATA_FILENAME)
        self.logger.info(&#34;Writing concatenated MAF output to %s&#34; % out_path)
        output_df.to_csv(out_path, sep=&#34;\t&#34;)
        tmp.cleanup()

    def write_meta(self, out_dir):
        &#34;&#34;&#34;cBioPortal. Write mutation metadata.&#34;&#34;&#34;
        try:
            meta = {
                constants.STUDY_ID_KEY: self.study_id,
                constants.GENETIC_ALTERATION_TYPE_KEY: constants.MUTATION_TYPE,
                constants.DATATYPE_KEY: &#39;MAF&#39;,
                constants.STABLE_ID_KEY: &#39;mutations&#39;,
                constants.SHOW_PROFILE_IN_ANALYSIS_TAB_KEY: True,
                constants.PROFILE_NAME_KEY: self.metadata[constants.PROFILE_NAME_KEY],
                constants.PROFILE_DESCRIPTION_KEY: self.metadata[constants.PROFILE_DESCRIPTION_KEY],
                constants.DATA_FILENAME_KEY: self.DATA_FILENAME,
            }
            # omitting optional meta keys for now:
            # - gene_panel
            # - swissprot_identifier
            # - variant_classification_filter
            # - namespaces
        except KeyError as err:
            self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
            raise
        with open(os.path.join(out_dir, self.META_FILENAME), &#39;w&#39;) as out_file:
            out_file.write(yaml.dump(meta, sort_keys=True))

    def write(self, out_dir):
        self.write_data(out_dir)
        self.write_meta(out_dir)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></li>
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.mutation_extended.BED_PATH_KEY"><code class="name">var <span class="ident">BED_PATH_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.CANCER_TYPE_KEY"><code class="name">var <span class="ident">CANCER_TYPE_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.DATA_FILENAME"><code class="name">var <span class="ident">DATA_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.META_FILENAME"><code class="name">var <span class="ident">META_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.TCGA_PATH_KEY"><code class="name">var <span class="ident">TCGA_PATH_KEY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.mutation_extended.get_gene_names"><code class="name flex">
<span>def <span class="ident">get_gene_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gene names from the input MAF files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_names(self):
    &#34;&#34;&#34;Find gene names from the input MAF files&#34;&#34;&#34;
    if self.gene_names:
        return self.gene_names
    gene_name_set = set()
    for sample_id in self.sample_ids:
        # pandas read_csv() will automatically decompress .gz input
        self.logger.debug(&#34;Reading gene names from %s/%s&#34; % (self.input_directory, input_file))
        df = pd.read_csv(
            self.get_input_path(sample_id),
            delimiter=&#34;\t&#34;,
            usecols=[self.HUGO_SYMBOL],
            comment=&#34;#&#34;
        )
        sample_gene_names = set(df[self.HUGO_SYMBOL].tolist())
        if len(gene_name_set) == 0:
            gene_name_set = sample_gene_names
        elif sample_gene_names != gene_name_set:
            self.logger.warning(&#34;Gene name sets are not consistent between input MAF files&#34;)
    # convert to list and sort
    gene_names = sorted(list(gene_name_set))
    self.gene_names = gene_names # store the gene names in case needed later
    return gene_names</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Find gene-level mutation fields using the mutation_extended_gene_metrics class:
- Gene
- Chromosome
- Protein Change
- Variant Reads And Total Reads
- Allele Fraction Percentile
- OncoKB
- FDA Approved Treatment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;
    Find gene-level mutation fields using the mutation_extended_gene_metrics class:
    - Gene
    - Chromosome
    - Protein Change
    - Variant Reads And Total Reads
    - Allele Fraction Percentile
    - OncoKB
    - FDA Approved Treatment
    &#34;&#34;&#34;
    self.logger.debug(&#34;Finding mutation_extended gene metrics&#34;)
    return mutation_extended_gene_metrics(
        self.get_input_path(sample_id),
        self.logger.getEffectiveLevel(),
        self.log_path
    ).get_metrics()</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, out_dir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, out_dir):
    self.write_data(out_dir)
    self.write_meta(out_dir)</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.write_data"><code class="name flex">
<span>def <span class="ident">write_data</span></span>(<span>self, out_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>cBioPortal. Write mutation data table.</p>
<ul>
<li>Read mutation data in MAF format and output in cBioPortal's required MAF format</li>
<li>May enable VCF input at a later date</li>
<li>see <a href="https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data">https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data</a></li>
<li>required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_data(self, out_dir):
    &#34;&#34;&#34;cBioPortal. Write mutation data table.

    - Read mutation data in MAF format and output in cBioPortal&#39;s required MAF format
    - May enable VCF input at a later date
    - see https://docs.cbioportal.org/5.1-data-loading/data-loading/file-formats#mutation-data
    - required modules: vcf2maf/1.6.17, vep/92.0, vep-hg19-cache/92, hg19/p13
    &#34;&#34;&#34;
    tmp = tempfile.TemporaryDirectory(prefix=&#39;djerba_mutex_&#39;)
    tmp_dir = tmp.name
    #tmp_dir = &#39;/scratch2/users/ibancarz/djerba_test/latest&#39; # temporary location for testing
    input_paths = [os.path.join(self.input_directory, name) for name in self.input_files.values()]
    uncompressed = system_tools.decompress_gzip(input_paths, tmp_dir)
    commands = []
    output_paths = []
    for input_name in uncompressed:
        in_path = os.path.join(tmp_dir, input_name)
        out_path = os.path.join(tmp_dir, &#39;cbioportal.{}&#39;.format(input_name))
        cmd = &#34;maf2maf &#34;+\
              &#34;--input-maf {} &#34;.format(in_path)+\
              &#34;--output-maf {} &#34;.format(out_path)+\
              &#34;--ref-fasta ${HG19_ROOT}/hg19_random.fa &#34;+\
              &#34;--vep-path ${VEP_ROOT}/bin &#34;+\
              &#34;--vep-data ${VEP_HG19_CACHE_ROOT}/.vep &#34;+\
              &#34;--filter-vcf &#34;+self.metadata.get(self.FILTER_VCF_KEY)
        commands.append(cmd)
        output_paths.append(out_path)
    # run the maf2maf commands
    system_tools.run_subprocesses(commands, self.logger)
    # concatenate the outputs by appending to a pandas DataFrame
    output_df = pd.read_csv(output_paths[0], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
    self.logger.debug(&#34;Read %s dataframe from %s&#34; % (str(output_df.shape), output_paths[0]))
    for i in range(1, len(output_paths)):
        self.logger.debug(&#34;Appending %s dataframe from %s&#34; % (str(output_df.shape), output_paths[i]))
        next_output = pd.read_csv(output_paths[i], delimiter=&#34;\t&#34;, comment=&#34;#&#34;)
        output_df = output_df.append(next_output)
    self.logger.debug(&#34;Dimensions of output dataframe are %s&#34; % str(output_df.shape))
    out_path = os.path.join(out_dir, self.DATA_FILENAME)
    self.logger.info(&#34;Writing concatenated MAF output to %s&#34; % out_path)
    output_df.to_csv(out_path, sep=&#34;\t&#34;)
    tmp.cleanup()</code></pre>
</details>
</dd>
<dt id="djerba.genetic_alteration.mutation_extended.write_meta"><code class="name flex">
<span>def <span class="ident">write_meta</span></span>(<span>self, out_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>cBioPortal. Write mutation metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_meta(self, out_dir):
    &#34;&#34;&#34;cBioPortal. Write mutation metadata.&#34;&#34;&#34;
    try:
        meta = {
            constants.STUDY_ID_KEY: self.study_id,
            constants.GENETIC_ALTERATION_TYPE_KEY: constants.MUTATION_TYPE,
            constants.DATATYPE_KEY: &#39;MAF&#39;,
            constants.STABLE_ID_KEY: &#39;mutations&#39;,
            constants.SHOW_PROFILE_IN_ANALYSIS_TAB_KEY: True,
            constants.PROFILE_NAME_KEY: self.metadata[constants.PROFILE_NAME_KEY],
            constants.PROFILE_DESCRIPTION_KEY: self.metadata[constants.PROFILE_DESCRIPTION_KEY],
            constants.DATA_FILENAME_KEY: self.DATA_FILENAME,
        }
        # omitting optional meta keys for now:
        # - gene_panel
        # - swissprot_identifier
        # - variant_classification_filter
        # - namespaces
    except KeyError as err:
        self.logger.error(&#34;Missing required config key: {0}&#34;.format(err))
        raise
    with open(os.path.join(out_dir, self.META_FILENAME), &#39;w&#39;) as out_file:
        out_file.write(yaml.dump(meta, sort_keys=True))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.is_null" href="utilities/base.html#djerba.utilities.base.base.is_null">is_null</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.update_gene_metrics" href="#djerba.genetic_alteration.genetic_alteration.update_gene_metrics">update_gene_metrics</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="djerba.genetic_alteration.segmented"><code class="flex name class">
<span>class <span class="ident">segmented</span></span>
<span>(</span><span>config, study_id=None, log_level=30, log_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Segmented data format from cBioPortal; input is SEG files.</p>
<p>Currently supports Elba output only, not cBioPortal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class segmented(genetic_alteration):
    &#34;&#34;&#34;
    Segmented data format from cBioPortal; input is SEG files.

    Currently supports Elba output only, not cBioPortal.
    &#34;&#34;&#34;

    MINIMUM_ABS_SEG_MEAN = 0.2

    def _find_all_sample_attributes(self):
        &#34;&#34;&#34;Find FGA for each SEG file&#34;&#34;&#34;
        attributes = {}
        for sample_id in self.sample_ids:
            seg_path = os.path.join(self.input_directory, self.input_files[sample_id])
            sample_attributes = {
                constants.FRACTION_GENOME_ALTERED_KEY: self._find_fga(seg_path, sample_id)
            }
            attributes[sample_id] = sample_attributes
        return attributes

    def _find_fga(self, seg_path, sample_id):
        seg = pd.read_csv(seg_path, sep=&#39;\t&#39;, skiprows= 0)
        # ID column of .seg file may be of the form ${SAMPLE_ID}.tumour.bam.varscanSomatic
        # Match against $SAMPLE_ID, followed by end-of-string OR a dot followed by a word character
        # Escape the $SAMPLE_ID in case it contains regex metacharacters
        # This will not catch pathological cases, eg. two samples with respective IDs &#34;foo&#34; and &#34;foo.bar&#34;
        seg_sample = seg.loc[seg.ID.str.match(re.escape(sample_id)+&#34;(\.\w|$)&#34;)]
        seg_alt = seg_sample.loc[abs(seg_sample[&#34;seg.mean&#34;]) &gt; self.MINIMUM_ABS_SEG_MEAN]
        denom = sum(seg_sample[&#39;loc.end&#39;] - seg_sample[&#39;loc.start&#39;])
        try:
            fga = sum(seg_alt[&#39;loc.end&#39;] - seg_alt[&#39;loc.start&#39;])/denom
        except ZeroDivisionError:
            self.logger.warning(&#39;FGA interval has zero width; FRACTION_GENOME_ALTERED is NA&#39;)
            fga = &#34;NA&#34;
        return fga

    def get_metrics_by_gene(self, sample_id):
        &#34;&#34;&#34;Return an empty dictionary, because SEG data has no gene-level metrics&#34;&#34;&#34;
        self.logger.debug(&#34;SEG data has no gene-level metrics, only sample-level; returning empty dictionary&#34;)
        return {}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></li>
<li><a title="djerba.utilities.base.base" href="utilities/base.html#djerba.utilities.base.base">base</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="djerba.genetic_alteration.segmented.MINIMUM_ABS_SEG_MEAN"><code class="name">var <span class="ident">MINIMUM_ABS_SEG_MEAN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="djerba.genetic_alteration.segmented.get_metrics_by_gene"><code class="name flex">
<span>def <span class="ident">get_metrics_by_gene</span></span>(<span>self, sample_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an empty dictionary, because SEG data has no gene-level metrics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metrics_by_gene(self, sample_id):
    &#34;&#34;&#34;Return an empty dictionary, because SEG data has no gene-level metrics&#34;&#34;&#34;
    self.logger.debug(&#34;SEG data has no gene-level metrics, only sample-level; returning empty dictionary&#34;)
    return {}</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></b></code>:
<ul class="hlist">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_gene_names" href="#djerba.genetic_alteration.genetic_alteration.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_logger" href="utilities/base.html#djerba.utilities.base.base.get_logger">get_logger</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.is_null" href="utilities/base.html#djerba.utilities.base.base.is_null">is_null</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.update_gene_metrics" href="#djerba.genetic_alteration.genetic_alteration.update_gene_metrics">update_gene_metrics</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="djerba" href="index.html">djerba</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="djerba.genetic_alteration.custom_annotation" href="#djerba.genetic_alteration.custom_annotation">custom_annotation</a></code></h4>
<ul class="two-column">
<li><code><a title="djerba.genetic_alteration.custom_annotation.GENE_HEADERS_KEY" href="#djerba.genetic_alteration.custom_annotation.GENE_HEADERS_KEY">GENE_HEADERS_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.GENE_TSV_KEY" href="#djerba.genetic_alteration.custom_annotation.GENE_TSV_KEY">GENE_TSV_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.SAMPLE_HEADERS_KEY" href="#djerba.genetic_alteration.custom_annotation.SAMPLE_HEADERS_KEY">SAMPLE_HEADERS_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.SAMPLE_TSV_KEY" href="#djerba.genetic_alteration.custom_annotation.SAMPLE_TSV_KEY">SAMPLE_TSV_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.get_gene_names" href="#djerba.genetic_alteration.custom_annotation.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.custom_annotation.get_metrics_by_gene" href="#djerba.genetic_alteration.custom_annotation.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.genetic_alteration" href="#djerba.genetic_alteration.genetic_alteration">genetic_alteration</a></code></h4>
<ul class="">
<li><code><a title="djerba.genetic_alteration.genetic_alteration.FILTER_VCF_KEY" href="#djerba.genetic_alteration.genetic_alteration.FILTER_VCF_KEY">FILTER_VCF_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.INPUT_DIRECTORY_KEY" href="#djerba.genetic_alteration.genetic_alteration.INPUT_DIRECTORY_KEY">INPUT_DIRECTORY_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.INPUT_FILES_KEY" href="#djerba.genetic_alteration.genetic_alteration.INPUT_FILES_KEY">INPUT_FILES_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.METADATA_KEY" href="#djerba.genetic_alteration.genetic_alteration.METADATA_KEY">METADATA_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.REGIONS_BED_KEY" href="#djerba.genetic_alteration.genetic_alteration.REGIONS_BED_KEY">REGIONS_BED_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.WORKFLOW_RUN_ID_KEY" href="#djerba.genetic_alteration.genetic_alteration.WORKFLOW_RUN_ID_KEY">WORKFLOW_RUN_ID_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_alteration_id" href="#djerba.genetic_alteration.genetic_alteration.get_alteration_id">get_alteration_id</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample" href="#djerba.genetic_alteration.genetic_alteration.get_attributes_for_sample">get_attributes_for_sample</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_datatype" href="#djerba.genetic_alteration.genetic_alteration.get_datatype">get_datatype</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_gene_names" href="#djerba.genetic_alteration.genetic_alteration.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_genetic_alteration_type" href="#djerba.genetic_alteration.genetic_alteration.get_genetic_alteration_type">get_genetic_alteration_type</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_input_path" href="#djerba.genetic_alteration.genetic_alteration.get_input_path">get_input_path</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_metrics_by_gene" href="#djerba.genetic_alteration.genetic_alteration.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.get_sample_ids" href="#djerba.genetic_alteration.genetic_alteration.get_sample_ids">get_sample_ids</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration.update_gene_metrics" href="#djerba.genetic_alteration.genetic_alteration.update_gene_metrics">update_gene_metrics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.genetic_alteration_factory" href="#djerba.genetic_alteration.genetic_alteration_factory">genetic_alteration_factory</a></code></h4>
<ul class="">
<li><code><a title="djerba.genetic_alteration.genetic_alteration_factory.CLASSNAMES" href="#djerba.genetic_alteration.genetic_alteration_factory.CLASSNAMES">CLASSNAMES</a></code></li>
<li><code><a title="djerba.genetic_alteration.genetic_alteration_factory.create_instance" href="#djerba.genetic_alteration.genetic_alteration_factory.create_instance">create_instance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.mutation_extended" href="#djerba.genetic_alteration.mutation_extended">mutation_extended</a></code></h4>
<ul class="two-column">
<li><code><a title="djerba.genetic_alteration.mutation_extended.BED_PATH_KEY" href="#djerba.genetic_alteration.mutation_extended.BED_PATH_KEY">BED_PATH_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.CANCER_TYPE_KEY" href="#djerba.genetic_alteration.mutation_extended.CANCER_TYPE_KEY">CANCER_TYPE_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.DATA_FILENAME" href="#djerba.genetic_alteration.mutation_extended.DATA_FILENAME">DATA_FILENAME</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.META_FILENAME" href="#djerba.genetic_alteration.mutation_extended.META_FILENAME">META_FILENAME</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.TCGA_PATH_KEY" href="#djerba.genetic_alteration.mutation_extended.TCGA_PATH_KEY">TCGA_PATH_KEY</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.get_gene_names" href="#djerba.genetic_alteration.mutation_extended.get_gene_names">get_gene_names</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.get_metrics_by_gene" href="#djerba.genetic_alteration.mutation_extended.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.write" href="#djerba.genetic_alteration.mutation_extended.write">write</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.write_data" href="#djerba.genetic_alteration.mutation_extended.write_data">write_data</a></code></li>
<li><code><a title="djerba.genetic_alteration.mutation_extended.write_meta" href="#djerba.genetic_alteration.mutation_extended.write_meta">write_meta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="djerba.genetic_alteration.segmented" href="#djerba.genetic_alteration.segmented">segmented</a></code></h4>
<ul class="">
<li><code><a title="djerba.genetic_alteration.segmented.MINIMUM_ABS_SEG_MEAN" href="#djerba.genetic_alteration.segmented.MINIMUM_ABS_SEG_MEAN">MINIMUM_ABS_SEG_MEAN</a></code></li>
<li><code><a title="djerba.genetic_alteration.segmented.get_metrics_by_gene" href="#djerba.genetic_alteration.segmented.get_metrics_by_gene">get_metrics_by_gene</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>